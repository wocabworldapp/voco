"use client"
import { useState, useEffect, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Topic, VocabularyWord, VocabularyResponse, getTopics, getVocabularyForTopic } from "@/lib/database"
import { useProgress, useSession, useWordProgress } from "@/hooks/useProgress"
import { MasteryBadge, StatCard } from "@/components/progress/ProgressComponents"
import { ProgressDashboard } from "@/components/progress/ProgressDashboard"
import { WordMastery } from "@/lib/progress"

// Algenib TTS integration
declare global {
  interface Window {
    AlgenibAudioService: any;
  }
}
import {
  Search,
  Languages,
  MessageCircle,
  Calculator,
  Clock,
  Sun,
  AlertTriangle,
  Users,
  Heart,
  User,
  Activity,
  Briefcase,
  Globe,
  UtensilsCrossed,
  ChefHat,
  Home,
  ShoppingCart,
  Shirt,
  Wrench,
  Smartphone,
  MapPin,
  Car,
  Gamepad2,
  Palette,
  Wifi,
  Shapes,
  Leaf,
  Dog,
  Cloud,
  GraduationCap,
  Rocket,
  BookOpen,
  Church,
  Scale,
  Shield,
  Sparkles,
  Radio,
  PartyPopper,
  ChevronLeft,
  ChevronRight,
  Play,
  Pause,
  Square,
  Settings,
  ArrowLeft,
  X,
} from "lucide-react"

// Topic icon mapping for our new 39 topics
const TOPIC_ICONS = [
  { id: 1, icon: MessageCircle }, // Greetings
  { id: 2, icon: Calculator }, // Numbers
  { id: 3, icon: Clock }, // Time & Dates
  { id: 4, icon: MapPin }, // Directions & Transportation
  { id: 5, icon: ShoppingCart }, // Shopping & Money
  { id: 6, icon: UtensilsCrossed }, // Food, Drinks & Restaurants
  { id: 7, icon: AlertTriangle }, // Emergency & Safety
  { id: 8, icon: Heart }, // Health & Body Parts
  { id: 9, icon: Home }, // Home & Household Items
  { id: 10, icon: Shirt }, // Clothing & Personal Style
  { id: 11, icon: Sun }, // Weather & Seasons
  { id: 12, icon: Users }, // Family & Relationships
  { id: 13, icon: Heart }, // Emotions & Feelings
  { id: 14, icon: User }, // Personality & Character
  { id: 15, icon: Activity }, // Hobbies & Leisure Activities
  { id: 16, icon: Gamepad2 }, // Sports & Fitness
  { id: 17, icon: MapPin }, // Places Around Town
  { id: 18, icon: Car }, // Travel & Tourism
  { id: 19, icon: Shapes }, // Colors & Shapes
  { id: 20, icon: Leaf }, // Nature
  { id: 21, icon: Activity }, // Actions
  { id: 22, icon: BookOpen }, // Adjectives
  { id: 23, icon: Palette }, // Arts & Entertainment
  { id: 24, icon: Smartphone }, // Technology & Gadgets
  { id: 25, icon: Briefcase }, // Work & Professions
  { id: 26, icon: GraduationCap }, // Education & School Life
  { id: 27, icon: Radio }, // Communication & Media
  { id: 28, icon: Leaf }, // Environment & Sustainability
  { id: 29, icon: Briefcase }, // Business & Economics
  { id: 30, icon: BookOpen }, // Common Collocations
  { id: 31, icon: Wifi }, // Slang & Modern Expressions
  { id: 32, icon: Rocket }, // Science & Technology
  { id: 33, icon: Calculator }, // Mathematics & Geometry
  { id: 34, icon: BookOpen }, // History & Culture
  { id: 35, icon: Scale }, // Politics & Law
  { id: 36, icon: Church }, // Religion & Philosophy
  { id: 37, icon: Sparkles }, // Mythology & Fantasy
  { id: 38, icon: PartyPopper }, // Celebrations & Holidays
  { id: 39, icon: BookOpen }, // Advanced Communication & Formal Language
  { id: 40, icon: Globe }, // Cultural Integration & Global Perspectives
]

type PageState = "native" | "target" | "confirmation" | "learning"

export function LanguageSelector() {
  const [currentPage, setCurrentPage] = useState<PageState>("native")
  const [isTransitioning, setIsTransitioning] = useState(false)
  const [nativeLanguage, setNativeLanguage] = useState("")
  const [nativeLanguageCode, setNativeLanguageCode] = useState("")
  const [targetLanguage, setTargetLanguage] = useState("")
  const [targetLanguageCode, setTargetLanguageCode] = useState("")
  const [selectedTopic, setSelectedTopic] = useState<Topic | null>(null)
  const [searchQuery, setSearchQuery] = useState("")
  const [questionText, setQuestionText] = useState("What language do you speak?")
  const [currentWordIndex, setCurrentWordIndex] = useState(0)
  const [showSettings, setShowSettings] = useState(false)
  const [settings, setSettings] = useState({
    autoPlay: true, // Auto-play enabled by default as requested
    trainingLanguageVoice: "Male" as "Female" | "Male", // Changed to Male
    mainLanguageVoice: "Male" as "Female" | "Male",
    pronunciationSpeed: "Normal" as "Slow" | "Normal" | "Fast",
    pauseBetweenTranslations: 0.5, // 0.5 seconds by default
    pauseForNextWord: 0.7, // 0.7 seconds by default
    repeatTargetLanguage: 1, // 1x by default
    repeatMainLanguage: 1, // 1x by default
  })

  // Audio state
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentAudioStep, setCurrentAudioStep] = useState<'training' | 'main' | 'pause' | 'idle'>('idle')
  // User interaction tracking to prevent auto-play on page load
  const [hasUserInteracted, setHasUserInteracted] = useState(false)
  const [autoPlayActive, setAutoPlayActive] = useState(false)
  
  // Ref to track auto-play state for cancellation
  const autoPlayRef = useRef(false)
  
  // Hybrid audio service for Umbriel + TTS
  const [hasUmbrielAudio, setHasUmbrielAudio] = useState(false)
  const [umbrielStatus, setUmbrielStatus] = useState<string>("")
  const [activeAudioService, setActiveAudioService] = useState<string>("None")

  // TTS Language code mapping
  const getLanguageCode = (languageName: string): string => {
    const languageMap: { [key: string]: string } = {
      'English': 'en-US',
      'Spanish': 'es-ES',
      'French': 'fr-FR',
      'German': 'de-DE',
      'Italian': 'it-IT',
      'Portuguese': 'pt-PT',
      'Dutch': 'nl-NL',
      'Russian': 'ru-RU',
      'Chinese': 'zh-CN',
      'Japanese': 'ja-JP',
      'Korean': 'ko-KR',
      'Arabic': 'ar-SA',
      'Hindi': 'hi-IN',
      'Turkish': 'tr-TR',
      'Polish': 'pl-PL',
      'Swedish': 'sv-SE',
      'Norwegian': 'no-NO',
      'Danish': 'da-DK',
      'Finnish': 'fi-FI',
      'Greek': 'el-GR',
      'Hebrew': 'he-IL',
      'Thai': 'th-TH',
      'Vietnamese': 'vi-VN',
      'Indonesian': 'id-ID',
      'Malay': 'ms-MY',
      'Czech': 'cs-CZ',
      'Hungarian': 'hu-HU',
      'Romanian': 'ro-RO',
      'Bulgarian': 'bg-BG',
      'Croatian': 'hr-HR',
      'Serbian': 'sr-RS',
      'Slovak': 'sk-SK',
      'Slovenian': 'sl-SI',
      'Estonian': 'et-EE',
      'Latvian': 'lv-LV',
      'Lithuanian': 'lt-LT',
      'Ukrainian': 'uk-UA',
      'Bengali': 'bn-BD',
      'Urdu': 'ur-PK',
      'Persian': 'fa-IR',
    }
    return languageMap[languageName] || 'en-US'
  }

  // Get available voices for a language - TTS DISABLED
  const getVoiceForLanguage = (languageCode: string, gender: 'Female' | 'Male'): any => {
    // const voices = speechSynthesis.getVoices()
    console.log('TTS disabled - voice selection skipped:', { languageCode, gender })
    return null
  }

  // Speech speed mapping
  const getSpeedRate = (speed: string): number => {
    switch (speed) {
      case 'Slow': return 0.7
      case 'Fast': return 1.3
      default: return 1.0 // Normal
    }
  }

  // Speak function with Promise support
  const speak = (text: string, languageCode: string, voice: SpeechSynthesisVoice | null): Promise<void> => {
    return new Promise((resolve, reject) => {
      // Enhanced validation to handle all edge cases
      if (!text || text === undefined || text === null || typeof text !== 'string') {
        console.warn('speak() called with invalid text:', text)
        resolve()
        return
      }

      const trimmedText = String(text).trim()
      if (!trimmedText || trimmedText.length === 0) {
        console.warn('speak() called with empty text after trimming:', text)
        resolve()
        return
      }

      try {
        // const utterance = new SpeechSynthesisUtterance(trimmedText)
        // utterance.lang = languageCode
        // utterance.rate = getSpeedRate(settings.pronunciationSpeed)
        
        // if (voice) {
        //   utterance.voice = voice
        // }

        // utterance.onend = () => resolve()
        // utterance.onerror = (error) => {
        //   console.error('Speech synthesis error:', error)
        //   reject(error)
        // }

        // speechSynthesis.speak(utterance) // TTS DISABLED
        console.log('TTS disabled - would speak:', trimmedText, 'in', languageCode)
        resolve() // Immediately resolve since no actual speech
      } catch (error) {
        console.error('Error in speak function:', error)
        reject(error)
      }
    })
  }

  // Sleep function for pauses
  const sleep = (ms: number): Promise<void> => {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  // Multi-voice Audio Service Integration
  const [algenibService, setAlgenibService] = useState<any>(null)
  const [alnilamService, setAlnilamService] = useState<any>(null)
  
  // Audio control for immediate stopping
  const [currentAudioElements, setCurrentAudioElements] = useState<Audio[]>([])
  const audioElementsRef = useRef<Audio[]>([])
  const stopRequestedRef = useRef(false)
  
  // Initialize Algenib Audio Service
  useEffect(() => {
    // Dynamically import the Algenib audio service
    const initAlgenib = async () => {
      try {
        // Load the service from the public directory
        if (typeof window !== 'undefined') {
          const script = document.createElement('script')
          script.src = '/lib/algenib-audio-service.js'
          script.onload = () => {
            if (window.AlgenibAudioService) {
              const service = new window.AlgenibAudioService()
              setAlgenibService(service)
              setActiveAudioService("Algenib")
              console.log('üé§ Algenib Audio Service initialized')
            }
          }
          document.head.appendChild(script)
        }
      } catch (error) {
        console.error('Failed to initialize Algenib service:', error)
      }
    }
    
    initAlgenib()
  }, [])

  // Initialize Alnilam Audio Service
  useEffect(() => {
    const initAlnilam = () => {
      try {
        console.log('üöÄ Starting Alnilam service initialization...') // Updated for debugging
        console.log('üîç initAlnilam function called - checking environment');
        
        // Create service directly with all needed methods
        const alnilamAudioService = {
          async playWordSequence(sourceWord, targetWord, settings, wordId, sourceLanguage, targetLanguage) {
            console.log('üéµ Alnilam playWordSequence called:', {
              sourceWord, targetWord, sourceLanguage, targetLanguage, wordId
            });

            try {
              // Reset stop flag
              stopRequestedRef.current = false;
              
              // Clear any existing audio elements
              audioElementsRef.current.forEach(audio => {
                try {
                  audio.pause();
                  audio.src = '';
                } catch (e) {}
              });
              audioElementsRef.current = [];

              // Convert language names to codes
              const languageMappings = {
                'Arabic': 'ar', 'German': 'de', 'Spanish': 'es', 'French': 'fr',
                'Hindi': 'hi', 'Indonesian': 'id', 'Italian': 'it', 'Japanese': 'ja',
                'Korean': 'ko', 'Portuguese': 'pt', 'Russian': 'ru', 'Dutch': 'nl',
                'Polish': 'pl', 'Thai': 'th', 'Turkish': 'tr', 'Vietnamese': 'vi',
                'Romanian': 'ro', 'Ukrainian': 'uk', 'Bengali': 'bn', 'Marathi': 'mr',
                'Tamil': 'ta', 'Telugu': 'te', 'English': 'en'
              };

              const sourceLangCode = languageMappings[sourceLanguage] || sourceLanguage.toLowerCase();
              const targetLangCode = languageMappings[targetLanguage] || targetLanguage.toLowerCase();

              console.log(`üåü Playing Alnilam audio: TARGET FIRST ${targetWord} (${targetLangCode}) ‚Üí THEN SOURCE ${sourceWord} (${sourceLangCode})`);

              // CRITICAL FIX: Enable audio context for autoplay policy
              try {
                // Try to resume AudioContext if it's suspended (autoplay policy)
                if (typeof window !== 'undefined' && window.AudioContext) {
                  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                  if (audioContext.state === 'suspended') {
                    console.log('üîì Resuming AudioContext for autoplay...');
                    await audioContext.resume();
                  }
                }
              } catch (audioContextError) {
                console.log('‚ö†Ô∏è AudioContext resume failed (might be normal):', audioContextError.message);
              }

              // FIXED ORDER: Play TARGET language first (what user is learning)
              if (wordId && targetLangCode) {
                const targetUrl = `/api/alnilam-audio?wordId=${wordId}&languageCode=${targetLangCode}`;
                console.log(`üéØ Loading TARGET audio FIRST: ${targetUrl}`);
                
                // Set visual indicator for target language
                if (settings?.setCurrentAudioStep) {
                  settings.setCurrentAudioStep('training');
                }
                
                // FIXED MAPPING: Target language repeats (what user is learning)
                const targetRepeats = settings?.repeatTargetLanguage || 1;
                for (let i = 0; i < targetRepeats; i++) {
                  // Check if stop was requested
                  if (stopRequestedRef.current) {
                    console.log('üõë Stop requested during target audio');
                    return false;
                  }
                  
                  try {
                    const targetAudio = new Audio(targetUrl);
                    // Store audio element for stop functionality
                    audioElementsRef.current.push(targetAudio);
                    
                    // CRITICAL: Set audio properties for better browser compatibility
                    targetAudio.crossOrigin = 'anonymous';
                    targetAudio.preload = 'auto';
                    // Apply speed setting to audio playback
                    targetAudio.playbackRate = getSpeedRate(settings.speed || 'Normal');
                    
                    await new Promise((resolve, reject) => {
                      const timeout = setTimeout(() => {
                        reject(new Error('Audio timeout'));
                      }, 10000); // 10 second timeout
                      
                      targetAudio.onended = () => {
                        clearTimeout(timeout);
                        resolve(null);
                      };
                      targetAudio.onerror = (error) => {
                        clearTimeout(timeout);
                        reject(error);
                      };
                      targetAudio.oncanplaythrough = () => {
                        // Check stop flag before playing
                        if (stopRequestedRef.current) {
                          clearTimeout(timeout);
                          resolve(null);
                          return;
                        }
                        // Audio is ready to play
                        targetAudio.play().catch(reject);
                      };
                      
                      // Load the audio
                      targetAudio.load();
                    });
                    console.log(`‚úÖ TARGET audio played: ${targetWord} (${targetLangCode}) - Repeat ${i + 1}/${targetRepeats}`);
                    
                    // Small pause between repeats (except after last repeat)
                    if (i < targetRepeats - 1) {
                      await new Promise(resolve => setTimeout(resolve, 300));
                    }
                  } catch (error) {
                    console.log(`‚ö†Ô∏è TARGET audio failed: ${targetWord} (${targetLangCode}) - Repeat ${i + 1}`, error);
                    return false; // Return false on audio failure
                  }
                }

                // Pause between translations
                if (settings?.pauseBetweenTranslations) {
                  await new Promise(resolve => setTimeout(resolve, settings.pauseBetweenTranslations * 1000));
                }
              }

              // Check if stop was requested between target and source
              if (stopRequestedRef.current) {
                console.log('üõë Stop requested between target and source');
                return false;
              }

                            // FIXED ORDER: Play SOURCE language second (native/main language)
              if (wordId && sourceLangCode) {
                const sourceUrl = `/api/alnilam-audio?wordId=${wordId}&languageCode=${sourceLangCode}`;
                console.log(`üéµ Loading SOURCE audio SECOND: ${sourceUrl}`);
                
                // Set visual indicator for source language
                if (settings?.setCurrentAudioStep) {
                  settings.setCurrentAudioStep('main');
                }
                
                // FIXED MAPPING: Source language repeats (main/native language)
                const sourceRepeats = settings?.repeatMainLanguage || 1;
                for (let i = 0; i < sourceRepeats; i++) {
                  // Check if stop was requested
                  if (stopRequestedRef.current) {
                    console.log('üõë Stop requested during source audio');
                    return false;
                  }
                  
                  try {
                    const sourceAudio = new Audio(sourceUrl);
                    // Store audio element for stop functionality
                    audioElementsRef.current.push(sourceAudio);
                    
                    // Apply speed setting to source audio playback
                    sourceAudio.playbackRate = getSpeedRate(settings.speed || 'Normal');
                    
                    await new Promise((resolve, reject) => {
                      const timeout = setTimeout(() => {
                        reject(new Error('Audio timeout'));
                      }, 10000); // 10 second timeout
                      
                      sourceAudio.onended = () => {
                        clearTimeout(timeout);
                        resolve(null);
                      };
                      sourceAudio.onerror = (error) => {
                        clearTimeout(timeout);
                        reject(error);
                      };
                      sourceAudio.oncanplaythrough = () => {
                        // Check stop flag before playing
                        if (stopRequestedRef.current) {
                          clearTimeout(timeout);
                          resolve(null);
                          return;
                        }
                        sourceAudio.play().catch(reject);
                      };
                      
                      // Load the audio
                      sourceAudio.load();
                    });
                    console.log(`‚úÖ SOURCE audio played: ${sourceWord} (${sourceLangCode}) - Repeat ${i + 1}/${sourceRepeats}`);
                    
                    // Small pause between repeats (except after last repeat)
                    if (i < sourceRepeats - 1) {
                      await new Promise(resolve => setTimeout(resolve, 300));
                    }
                  } catch (error) {
                    console.log(`‚ö†Ô∏è SOURCE audio failed: ${sourceWord} (${sourceLangCode}) - Repeat ${i + 1}`);
                  }
                }
              }

              console.log('üéâ Alnilam sequence completed successfully');
              
              // Reset visual indicator to idle
              if (settings?.setCurrentAudioStep) {
                settings.setCurrentAudioStep('idle');
              }
              
              return true;

            } catch (error) {
              console.error('‚ùå Alnilam sequence failed:', error);
              return false;
            }
          },

          isAvailable() {
            return true;
          },

          getStatus() {
            return {
              available: true,
              name: 'Alnilam Multilingual Audio Service'
            };
          }
        };

        console.log('üåä Alnilam Audio Service initialized - Beautiful multilingual TTS');
        console.log('‚úÖ Alnilam service created:', alnilamAudioService);
        setAlnilamService(alnilamAudioService);
        console.log('‚úÖ Alnilam service set in state');
        setActiveAudioService("Alnilam");
        console.log('üåü Alnilam Audio Service initialized successfully');
        
        // IMMEDIATE TEST: Try calling the service right after initialization
        console.log('üß™ Testing Alnilam service immediately after initialization...');
        console.log('üß™ Service object test:', {
          serviceExists: !!alnilamAudioService,
          hasPlayMethod: !!alnilamAudioService.playWordSequence,
          serviceType: typeof alnilamAudioService
        });
        
      } catch (error) {
        console.error('‚ùå Failed to initialize Alnilam service:', error);
        console.log('Alnilam service not available, Algenib will be used instead');
      }
    }
    
    initAlnilam()
  }, [])

  // Main audio playback function - Algenib Enhanced
  const playAudio = async (word: any, autoPlay = false) => {
    if (!word || isPlaying) return

    // Enhanced validation for word data
    const sourceWord = word.sourceWord || word.training_word || ''
    const targetWord = word.targetWord || word.main_word || ''
    const wordId = word.id

    if (!sourceWord || typeof sourceWord !== 'string' || sourceWord.trim().length === 0) {
      console.warn('No valid source word found in:', word)
      return
    }
    if (!targetWord || typeof targetWord !== 'string' || targetWord.trim().length === 0) {
      console.warn('No valid target word found in:', word)
      return
    }

    console.log('üéì Algenib audio playback for:', { 
      wordId,
      sourceWord, 
      targetWord, 
      targetLanguage, 
      nativeLanguage,
      currentWordIndex,
      autoPlay,
      vocabularyLength: vocabulary.length
    })

    if (autoPlay) {
      setAutoPlayActive(true)
    }

    try {
      setIsPlaying(true)
      
      console.log('üéÆ Play button clicked - checking services...', {
        alnilamService: !!alnilamService,
        alnilamServiceType: typeof alnilamService,
        alnilamServiceDetails: alnilamService,
        algenibService: !!algenibService,
        wordId,
        sourceWord,
        targetWord,
        targetLanguage,
        nativeLanguage
      });
      
      // CRITICAL DEBUG: Check if Alnilam service is available
      if (!alnilamService) {
        console.error('üö® CRITICAL: Alnilam service is null/undefined!');
        console.log('üîç Service initialization status check needed');
      }
      
      if (!wordId) {
        console.error('üö® CRITICAL: wordId is missing!', { wordId });
      }
      
      // Priority 1: Try Alnilam Multilingual Audio first (54,738 files)
      if (alnilamService && wordId) {
        console.log('üåü Using Alnilam Multilingual Audio for comprehensive language support')
        console.log('üîß About to call playWordSequence with:', {
          sourceWord, targetWord, wordId, nativeLanguage, targetLanguage,
          settingsType: typeof settings,
          hasSetCurrentAudioStep: typeof setCurrentAudioStep
        })
        setActiveAudioService("Alnilam")
        
        try {
          const alnilamSuccess = await alnilamService.playWordSequence(
            sourceWord,           // sourceWord string
            targetWord,           // targetWord string  
            {                     // settings object
              speed: settings.pronunciationSpeed,
              pauseBetweenTranslations: settings.pauseBetweenTranslations,
              pauseForNextWord: settings.pauseForNextWord,
              repeatTargetLanguage: settings.repeatTargetLanguage,
              repeatMainLanguage: settings.repeatMainLanguage,
              setCurrentAudioStep
            },
            wordId,               // wordId
            nativeLanguage,       // sourceLanguage
            targetLanguage        // targetLanguage
          )
          
          console.log('üéµ Alnilam playWordSequence returned:', alnilamSuccess)
          
          if (alnilamSuccess) {
            console.log('‚úÖ Alnilam audio completed successfully')
            setCurrentAudioStep('idle')
            setIsPlaying(false)
            return
          } else {
            console.log('‚ö†Ô∏è Alnilam audio not available, trying Algenib...')
          }
        } catch (error) {
          console.error('‚ùå Alnilam service error:', error)
          console.log('üîÑ Falling back to Algenib due to Alnilam error')
        }
      } else {
        console.warn('‚ùå Alnilam service not available:', {
          hasService: !!alnilamService,
          hasWordId: !!wordId,
          serviceType: typeof alnilamService
        })
      }
      
      // Priority 2: Try Algenib TTS as backup
      if (algenibService && wordId) {
        console.log('üé§ Using Algenib TTS for professional teaching voice')
        setActiveAudioService("Algenib")
        
        const algenibSuccess = await algenibService.playWordSequence(
          { id: wordId, sourceWord, targetWord },
          targetLanguage,
          nativeLanguage,
          {
            repeatTargetLanguage: settings.repeatTargetLanguage,
            repeatMainLanguage: settings.repeatMainLanguage,
            pauseBetweenTranslations: settings.pauseBetweenTranslations
          }
        )
        
        if (algenibSuccess) {
          console.log('‚úÖ Algenib audio completed successfully')
          setCurrentAudioStep('idle')
          setIsPlaying(false)
          return
        } else {
          console.log('‚ö†Ô∏è Algenib audio not available, falling back to browser TTS')
        }
      }
      
      // Priority 3: Browser TTS fallback if neither Alnilam nor Algenib available
      console.log('üîÑ Using browser TTS as final fallback')
      setActiveAudioService("Browser TTS")
      setCurrentAudioStep('training')
      
      // Get voices for languages
      const trainingVoice = getVoiceForLanguage(targetLanguage, settings.trainingLanguageVoice)
      const mainVoice = getVoiceForLanguage(nativeLanguage, settings.mainLanguageVoice)

      // Play target language (what user is learning)
      for (let i = 0; i < settings.repeatTargetLanguage; i++) {
        await speak(sourceWord, targetLanguage, trainingVoice)
        if (i < settings.repeatTargetLanguage - 1) {
          await sleep(300)
        }
      }

      // Pause between languages
      setCurrentAudioStep('pause')
      await sleep(settings.pauseBetweenTranslations * 1000)

      // Play native language (translation)
      setCurrentAudioStep('main')
      for (let i = 0; i < settings.repeatMainLanguage; i++) {
        await speak(targetWord, nativeLanguage, mainVoice)
        if (i < settings.repeatMainLanguage - 1) {
          await sleep(300)
        }
      }

      // Set to idle after completing this word
      setCurrentAudioStep('idle')
      setIsPlaying(false)

    } catch (error) {
      console.error('Audio playback error:', error)
      setCurrentAudioStep('idle')
      setAutoPlayActive(false)
      setIsPlaying(false)
    }
  }

  // Stop audio function
  const stopAudio = () => {
    console.log('üõë Stop audio requested - immediate stop');
    
    // Set stop flag to interrupt any ongoing audio
    stopRequestedRef.current = true;
    
    // Immediately stop all currently playing audio elements
    audioElementsRef.current.forEach(audio => {
      try {
        audio.pause();
        audio.currentTime = 0;
        audio.src = '';
        console.log('üõë Stopped audio element');
      } catch (error) {
        console.log('‚ö†Ô∏è Error stopping audio element:', error);
      }
    });
    
    // Clear the audio elements array
    audioElementsRef.current = [];
    
    // Cancel the auto-play loop
    autoPlayRef.current = false
    
    // Stop hybrid audio service - TTS DISABLED
    console.log('Audio stop requested - TTS disabled')
    
    // Cancel any ongoing speech synthesis - TTS DISABLED
    // if (speechSynthesis.speaking) {
    //   speechSynthesis.cancel()
    // }
    
    // Reset all audio states
    setIsPlaying(false)
    setCurrentAudioStep('idle')
    setAutoPlayActive(false)
    
    console.log('‚úÖ Audio stopped immediately and all states reset')
  }

  // Database state
  const [topics, setTopics] = useState<Topic[]>([])
  const [vocabulary, setVocabulary] = useState<VocabularyWord[]>([])
  const [totalWords, setTotalWords] = useState<number>(0)
  const [currentOffset, setCurrentOffset] = useState<number>(0)
  const [hasMoreWords, setHasMoreWords] = useState<boolean>(false)
  
  // Progress tracking state (after vocabulary is declared)
  const [showProgressDashboard, setShowProgressDashboard] = useState(false)
  const { userProgress, session, newAchievements, dismissNewAchievements } = useProgress()
  
  // Get current word progress
  const currentWord = vocabulary.length > 0 ? vocabulary[currentWordIndex] : null
  const { wordProgress } = useWordProgress(currentWord?.id || null)
  const [isLoading, setIsLoading] = useState(false)

  // Load data from database on mount
  useEffect(() => {
    const loadData = async () => {
      setIsLoading(true)
      try {
        const topicsData = await getTopics()
        setTopics(topicsData)
      } catch (error) {
        console.error('Failed to load data:', error)
      } finally {
        setIsLoading(false)
      }
    }
    loadData()
  }, [])

  // Load vocabulary when topic and languages are selected
  useEffect(() => {
    const loadVocabulary = async () => {
      console.log('üîç Vocabulary loading effect triggered:', {
        selectedTopic: selectedTopic?.id,
        selectedTopicName: selectedTopic?.name,
        nativeLanguageCode,
        targetLanguageCode,
        nativeLanguage,
        targetLanguage,
        allConditionsMet: !!(selectedTopic && nativeLanguageCode && targetLanguageCode)
      })
      
      if (selectedTopic && nativeLanguageCode && targetLanguageCode) {
        console.log('‚úÖ Loading vocabulary for word training:', {
          topicId: selectedTopic.id,
          topicName: selectedTopic.name,
          trainingLanguage: `${targetLanguage} (${targetLanguageCode})`, // what user wants to learn
          mainLanguage: `${nativeLanguage} (${nativeLanguageCode})` // user's native language for translations
        })
        
        // Clear existing vocabulary to prevent showing old data
        setVocabulary([])
        setCurrentWordIndex(0)
        setIsLoading(true)
        
        try {
          // Load ALL vocabulary words at once instead of just 50
          // This ensures autoplay can continue through all words in the topic
          const vocabularyResponse = await getVocabularyForTopic(
            selectedTopic.id,
            targetLanguage, // Use full language name, not code
            nativeLanguage, // Use full language name, not code
            10000, // Load up to 10,000 words at once (should cover any topic size)
            0 // Start from offset 0
          )
          
          console.log('Vocabulary loaded:', vocabularyResponse.vocabulary.length, 'words out of', vocabularyResponse.totalWords)
          if (vocabularyResponse.vocabulary.length > 0) {
            console.log('Sample vocabulary:', vocabularyResponse.vocabulary.slice(0, 3))
            console.log('First word details:', vocabularyResponse.vocabulary[0])
          }
          setVocabulary(vocabularyResponse.vocabulary)
          setTotalWords(vocabularyResponse.totalWords)
          setCurrentOffset(vocabularyResponse.vocabulary.length) // Set offset to loaded words count
          setHasMoreWords(false) // No more words to load since we loaded everything
          setCurrentWordIndex(0)
          
          // Audio system removed - placeholder for new TTS implementation
          console.log(`üéµ Audio system removed for topic ${selectedTopic.id}: ${selectedTopic.name}`)
          setHasUmbrielAudio(false)
          setUmbrielStatus(`üîÑ TTS System Removed - Ready for New Implementation`)
          
          // Reset audio states when new vocabulary is loaded
          setIsPlaying(false)
          setCurrentAudioStep('idle')
          setAutoPlayActive(false)
          autoPlayRef.current = false
        } catch (error) {
          console.error('Failed to load vocabulary:', error)
          setVocabulary([])
        } finally {
          setIsLoading(false)
        }
      } else {
        console.log('‚ùå Vocabulary loading conditions not met:', {
          hasSelectedTopic: !!selectedTopic,
          hasNativeLanguageCode: !!nativeLanguageCode,
          hasTargetLanguageCode: !!targetLanguageCode,
          selectedTopic: selectedTopic?.name,
          nativeLanguageCode,
          targetLanguageCode
        })
      }
    }
    loadVocabulary()
  }, [selectedTopic, nativeLanguageCode, targetLanguageCode, nativeLanguage, targetLanguage])

  // Function to load more words when approaching end of current batch
  const loadMoreWords = async () => {
    if (!selectedTopic || !hasMoreWords || isLoading) return
    
    try {
      setIsLoading(true)
      console.log('Loading more words from offset:', currentOffset)
      
      const vocabularyResponse = await getVocabularyForTopic(
        selectedTopic.id,
        targetLanguageCode,
        nativeLanguageCode,
        50,
        currentOffset
      )
      
      if (vocabularyResponse.vocabulary.length > 0) {
        console.log('Loaded', vocabularyResponse.vocabulary.length, 'more words')
        // Append new words to existing vocabulary
        setVocabulary(prev => [...prev, ...vocabularyResponse.vocabulary])
        setCurrentOffset(prev => prev + 50)
        setHasMoreWords(vocabularyResponse.hasMore)
      }
    } catch (error) {
      console.error('Failed to load more vocabulary:', error)
    } finally {
      setIsLoading(false)
    }
  }

  // Auto-play controller function
  const startAutoPlay = async () => {
    if (!vocabulary.length || !settings.autoPlay) return
    
    console.log('Starting auto-play from word', currentWordIndex + 1)
    autoPlayRef.current = true // Enable auto-play loop
    
    for (let i = currentWordIndex; i < vocabulary.length; i++) {
      // Check if auto-play was cancelled
      if (!autoPlayRef.current) {
        console.log('Auto-play cancelled by user')
        break
      }
      
      const word = vocabulary[i]
      if (!word || !word.sourceWord || !word.targetWord) continue
      
      console.log(`Auto-play: Playing word ${i + 1} of ${vocabulary.length}`)
      
      // Update the display
      setCurrentWordIndex(i)
      
      // Play the word
      await playAudio(word, false)
      
      // Check again if auto-play was cancelled during playback
      if (!autoPlayRef.current) {
        console.log('Auto-play cancelled during playback')
        break
      }
      
      // Pause before next word (except for last word)
      if (i < vocabulary.length - 1) {
        setCurrentAudioStep('pause')
        await sleep(settings.pauseForNextWord * 1000)
      }
    }
    
    // Clean up when done
    autoPlayRef.current = false
    setAutoPlayActive(false)
    setIsPlaying(false)
    setCurrentAudioStep('idle')
    console.log('Auto-play sequence completed')
  }

  // Auto-play effect - only when manually triggered and user has interacted
  useEffect(() => {
    // Prevent auto-play on page load - require user interaction first
    if (autoPlayActive && !isPlaying && vocabulary.length > 0 && hasUserInteracted) {
      console.log('Auto-play triggered by user interaction')
      startAutoPlay()
    } else if (autoPlayActive && !hasUserInteracted) {
      console.log('Auto-play blocked - no user interaction yet')
      setAutoPlayActive(false) // Reset autoplay since user hasn't interacted
    }
  }, [autoPlayActive, hasUserInteracted])

  // Initialize multi-voice audio system - Alnilam + Algenib + Browser TTS
  useEffect(() => {
    console.log('üéµ Multi-voice audio system active: Alnilam (Priority 1) ‚Üí Algenib (Priority 2) ‚Üí Browser TTS (Fallback)')
  }, [])
  
  // Load voices for browser TTS fallback
  useEffect(() => {
    console.log('Browser TTS voices loaded for fallback scenarios')
  }, [])

  // Language names mapping for better display
  const getLanguageName = (languageCode: string): string => {
    const nameMap: { [key: string]: string } = {
      'af': 'Afrikaans',
      'am': 'Amharic',
      'ar': 'Arabic',
      'az': 'Azerbaijani',
      'be': 'Belarusian',
      'bg': 'Bulgarian',
      'bn': 'Bengali',
      'br': 'Breton',
      'bs': 'Bosnian',
      'ca': 'Catalan',
      'co': 'Corsican',
      'cs': 'Czech',
      'cy': 'Welsh',
      'da': 'Danish',
      'de': 'German',
      'el': 'Greek',
      'en': 'English',
      'eo': 'Esperanto',
      'es': 'Spanish',
      'et': 'Estonian',
      'eu': 'Basque',
      'fa': 'Persian',
      'fi': 'Finnish',
      'fo': 'Faroese',
      'fr': 'French',
      'ga': 'Irish',
      'gd': 'Scottish Gaelic',
      'gu': 'Gujarati',
      'ha': 'Hausa',
      'he': 'Hebrew',
      'hi': 'Hindi',
      'hr': 'Croatian',
      'hu': 'Hungarian',
      'id': 'Indonesian',
      'ig': 'Igbo',
      'is': 'Icelandic',
      'it': 'Italian',
      'ja': 'Japanese',
      'jv': 'Javanese',
      'ka': 'Georgian',
      'kk': 'Kazakh',
      'km': 'Khmer',
      'kn': 'Kannada',
      'ko': 'Korean',
      'ky': 'Kyrgyz',
      'la': 'Latin',
      'lb': 'Luxembourgish',
      'lo': 'Lao',
      'lt': 'Lithuanian',
      'lv': 'Latvian',
      'mg': 'Malagasy',
      'mk': 'Macedonian',
      'ml': 'Malayalam',
      'mn': 'Mongolian',
      'mr': 'Marathi',
      'ms': 'Malay',
      'mt': 'Maltese',
      'my': 'Myanmar',
      'ne': 'Nepali',
      'nl': 'Dutch',
      'no': 'Norwegian',
      'or': 'Odia',
      'pa': 'Punjabi',
      'pl': 'Polish',
      'ps': 'Pashto',
      'pt': 'Portuguese',
      'ro': 'Romanian',
      'ru': 'Russian',
      'rw': 'Kinyarwanda',
      'sa': 'Sanskrit',
      'si': 'Sinhala',
      'sk': 'Slovak',
      'sl': 'Slovenian',
      'sn': 'Shona',
      'so': 'Somali',
      'sq': 'Albanian',
      'sr': 'Serbian',
      'sv': 'Swedish',
      'sw': 'Swahili',
      'ta': 'Tamil',
      'te': 'Telugu',
      'tg': 'Tajik',
      'th': 'Thai',
      'tk': 'Turkmen',
      'tl': 'Filipino',
      'tr': 'Turkish',
      'uk': 'Ukrainian',
      'ur': 'Urdu',
      'uz': 'Uzbek',
      'vi': 'Vietnamese',
      'xh': 'Xhosa',
      'yo': 'Yoruba',
      'zh': 'Chinese',
      'zu': 'Zulu',
    }
    return nameMap[languageCode] || languageCode.toUpperCase()
  }

  // Create comprehensive language list from database codes
  const allLanguageCodes = ['af', 'am', 'ar', 'az', 'be', 'bg', 'bn', 'br', 'bs', 'ca', 'co', 'cs', 'cy', 'da', 'de', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr', 'ga', 'gd', 'gu', 'ha', 'he', 'hi', 'hr', 'hu', 'id', 'ig', 'is', 'it', 'ja', 'jv', 'ka', 'kk', 'km', 'kn', 'ko', 'ky', 'la', 'lb', 'lo', 'lt', 'lv', 'mg', 'mk', 'ml', 'mn', 'mr', 'ms', 'mt', 'my', 'ne', 'nl', 'no', 'or', 'pa', 'pl', 'ps', 'pt', 'ro', 'ru', 'rw', 'sa', 'si', 'sk', 'sl', 'sn', 'so', 'sq', 'sr', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'tk', 'tl', 'tr', 'uk', 'ur', 'uz', 'vi', 'xh', 'yo', 'zh', 'zu']
  
  // Create comprehensive language list with top 10 most common languages first, then alphabetical
  const topLanguages = ['en', 'es', 'fr', 'de', 'it', 'pt', 'ru', 'ja', 'ko', 'zh']
  const remainingLanguages = allLanguageCodes
    .filter(code => !topLanguages.includes(code))
    .sort((a, b) => getLanguageName(a).localeCompare(getLanguageName(b)))
  const orderedLanguageCodes = [...topLanguages, ...remainingLanguages]
  
  const enhancedLanguages = orderedLanguageCodes.map(code => ({
    code,
    name: getLanguageName(code)
  }))

  const filteredLanguages = enhancedLanguages.filter((lang) => {
    // Filter by search query
    const matchesSearch = lang.name.toLowerCase().includes(searchQuery.toLowerCase())
    
    // If we're on target language selection, exclude the native language
    if (currentPage === "target" && nativeLanguageCode) {
      return matchesSearch && lang.code !== nativeLanguageCode
    }
    
    return matchesSearch
  })

  useEffect(() => {
    if (nativeLanguage && currentPage === "native") {
      setIsTransitioning(true)
      setTimeout(() => {
        setQuestionText("choose the language\nyou want to train")
        setCurrentPage("target")
        setIsTransitioning(false)
      }, 300)
    }
  }, [nativeLanguage, currentPage])

  useEffect(() => {
    if (targetLanguage && currentPage === "target") {
      setIsTransitioning(true)
      setTimeout(() => {
        setCurrentPage("confirmation")
        setIsTransitioning(false)
      }, 300)
    }
  }, [targetLanguage, currentPage])

  const handleLanguageSelect = (language: { code: string; name: string }) => {
    console.log('Language selected:', language)
    if (currentPage === "native") {
      setNativeLanguage(language.name)
      setNativeLanguageCode(language.code)
      console.log('Native language set:', language.name, language.code)
      
      // Start fade animation
      setIsTransitioning(true)
      
      // Fade out, change content, then fade in
      setTimeout(() => {
        setQuestionText("choose the language\nyou want to train")
        setCurrentPage("target")
        setIsTransitioning(false)
      }, 300)
    } else if (currentPage === "target") {
      setTargetLanguage(language.name)
      setTargetLanguageCode(language.code)
      console.log('Target language set:', language.name, language.code)
      
      // Start fade animation
      setIsTransitioning(true)
      
      // Fade out, change content, then fade in
      setTimeout(() => {
        setCurrentPage("confirmation")
        setIsTransitioning(false)
      }, 300)
    }
    setSearchQuery("")
  }

  const handleContinue = () => {
    if (currentPage === "confirmation") {
      console.log("Starting language learning journey!")
    }
  }

  const handleLanguageCardClick = (type: "native" | "target") => {
    // Start fade animation
    setIsTransitioning(true)
    
    setTimeout(() => {
      if (type === "native") {
        setCurrentPage("native")
        setQuestionText("What language do you speak?")
        // Clear the native language so it can be reselected
        setNativeLanguage("")
        setNativeLanguageCode("")
      } else {
        setCurrentPage("target")
        setQuestionText("choose the language\nyou want to train")
        // Clear the target language so it can be reselected
        setTargetLanguage("")
        setTargetLanguageCode("")
      }
      setSearchQuery("")
      setIsTransitioning(false)
    }, 300)
  }

  const handleTopicSelect = (topic: Topic) => {
    setSelectedTopic(topic)
    setCurrentPage("learning")
    
    // Start a new learning session
    if (topic.id) {
      const languagePair = `${targetLanguage} ‚Üí ${nativeLanguage}`
      session.startSession(topic.id, topic.name, languagePair)
    }
  }

  const getCurrentContent = () => {
    if (isLoading) {
      return { sourceWord: "Loading...", targetWord: "Loading..." }
    }
    if (vocabulary.length === 0) {
      return { 
        sourceWord: `No ${targetLanguage} words found`, 
        targetWord: `Try a different topic or language combination` 
      }
    }
    const currentWord = vocabulary[currentWordIndex] || vocabulary[0]
    return {
      sourceWord: currentWord.sourceWord, // Training language word (what user wants to learn)
      targetWord: currentWord.targetWord  // Main language translation (user's native language)
    }
  }

  const handlePrevious = () => {
    if (vocabulary.length > 0) {
      // Stop any current audio and auto-play sequence
      stopAudio()
      
      const prevIndex = currentWordIndex - 1
      
      if (prevIndex >= 0) {
        setCurrentWordIndex(prevIndex)
      } else {
        // Go to the last word in the topic (totalWords - 1)
        // If we don't have all words loaded, we need to implement logic to jump to end
        // For now, just cycle within loaded words
        setCurrentWordIndex(vocabulary.length - 1)
      }
    }
  }

  const handleNext = () => {
    if (vocabulary.length > 0) {
      // Track word interaction before moving to next
      const currentWord = vocabulary[currentWordIndex]
      if (currentWord?.id && session.isSessionActive) {
        // Record that user studied this word (assuming they got it right for navigation)
        session.recordWordStudy(currentWord.id, true)
      }
      
      // Stop any current audio and auto-play sequence
      stopAudio()
      
      const nextIndex = currentWordIndex + 1
      
      // Navigate to next word or cycle back to beginning if at the end
      if (nextIndex < vocabulary.length) {
        setCurrentWordIndex(nextIndex)
      } else {
        // At the end of all words, cycle back to beginning
        setCurrentWordIndex(0)
      }
    }
  }

  const handlePlay = () => {
    // Mark that user has interacted (prevents auto-play on page load)
    setHasUserInteracted(true)
    
    // Track word interaction - user is actively engaging with the word
    const currentWord = vocabulary[currentWordIndex]
    if (currentWord?.id && session.isSessionActive) {
      // Record that user studied this word (assuming correct for audio engagement)
      session.recordWordStudy(currentWord.id, true)
    }
    
    if (isPlaying || autoPlayActive) {
      stopAudio()
    } else {
      const currentWord = vocabulary[currentWordIndex]
      if (currentWord) {
        console.log('Manual play button clicked')
        if (settings.autoPlay) {
          // Start auto-play sequence from current word
          autoPlayRef.current = true
          setAutoPlayActive(true)
        } else {
          // Just play the current word once
          setIsPlaying(true)
          playAudio(currentWord, false).then(() => {
            setIsPlaying(false)
          })
        }
      }
    }
  }

  const handleBackToTopics = () => {
    // Stop any currently playing audio when navigating back
    stopAudio()
    
    // End the current learning session
    if (session.isSessionActive) {
      session.endSession()
    }
    
    setCurrentPage("confirmation")
  }

  const handleSettingsClick = () => {
    setShowSettings(true)
  }

  const handleSettingsClose = () => {
    setShowSettings(false)
  }

  const updateSetting = (key: string, value: any) => {
    setSettings((prev) => ({ ...prev, [key]: value }))
  }

  return (
    <div className="w-full max-w-md mx-auto">
      <div className={`bg-black/40 backdrop-blur-xl border border-white/10 rounded-[32px] p-8 shadow-2xl transform transition-all duration-300 hover:scale-[1.02] hover:shadow-3xl ${isTransitioning ? 'bg-black/50' : 'bg-black/40'}`}>
        {isLoading && (
          <div className="text-center mb-4">
            <div className="inline-block animate-spin rounded-full h-6 w-6 border-b-2 border-white"></div>
            <p className="text-white/60 text-sm mt-2">Loading...</p>
          </div>
        )}
        
        {currentPage === "learning" && (
          <div className="text-center transition-all duration-500 ease-in-out">
            <div className="mb-12">
              <div className="flex items-center justify-between mb-8">
                <button
                  onClick={handleBackToTopics}
                  className="w-12 h-12 bg-black/20 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center hover:bg-black/30 transition-all duration-300 transform hover:scale-110"
                >
                  <ArrowLeft className="w-6 h-6 text-white/80" />
                </button>

                <div className="flex items-center gap-3">
                  {/* Topic Icon */}
                  {(() => {
                    const iconData = TOPIC_ICONS.find(icon => icon.id === selectedTopic?.id)
                    if (iconData) {
                      const IconComponent = iconData.icon
                      return <IconComponent className="w-8 h-8 text-white/80" />
                    }
                    return <BookOpen className="w-8 h-8 text-white/80" />
                  })()}
                  <h1 className="text-2xl font-medium text-white">{selectedTopic?.name}</h1>
                </div>
                
                <div className="flex items-center gap-2">
                  <button
                    onClick={() => setShowProgressDashboard(true)}
                    className="w-12 h-12 bg-black/20 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center hover:bg-black/30 transition-all duration-300 transform hover:scale-110"
                    title="View Progress"
                  >
                    <Activity className="w-6 h-6 text-white/80" />
                  </button>
                  <button
                    onClick={handleSettingsClick}
                    className="w-12 h-12 bg-black/20 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center hover:bg-black/30 transition-all duration-300 transform hover:scale-110"
                  >
                    <Settings className="w-6 h-6 text-white/80" />
                  </button>
                </div>
              </div>

              {/* Progress indicator */}
              {vocabulary.length > 0 && (
                <div className="mb-6 text-center">
                  <p className="text-white/60 text-sm">
                    {currentWordIndex + 1} of {vocabulary.length} words
                  </p>
                  <div className="w-full bg-black/20 rounded-full h-2 mt-2">
                    <div 
                      className="bg-gradient-to-r from-blue-400 to-green-400 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${((currentWordIndex + 1) / vocabulary.length) * 100}%` }}
                    />
                  </div>
                </div>
              )}

              <div className="space-y-6 mb-12">
                <div className={`backdrop-blur-sm border border-white/10 rounded-2xl p-8 transition-all duration-300 relative ${
                  currentAudioStep === 'training' 
                    ? 'bg-blue-500/20 border-blue-400/30 scale-105' 
                    : 'bg-black/20'
                }`}>
                  {/* Mastery Badge */}
                  {wordProgress && (
                    <div className="absolute top-4 right-4">
                      <MasteryBadge mastery={wordProgress.masteryLevel} size="sm" />
                    </div>
                  )}
                  <div className="text-white/60 text-sm mb-2 flex items-center gap-2">
                    {targetLanguage}
                    {currentAudioStep === 'training' && (
                      <div className="w-2 h-2 bg-blue-400 rounded-full animate-pulse" />
                    )}
                  </div>
                  <p className="text-white text-2xl font-medium">{getCurrentContent().sourceWord}</p>
                </div>
                <div className={`backdrop-blur-sm border border-white/10 rounded-2xl p-8 transition-all duration-300 relative ${
                  currentAudioStep === 'main' 
                    ? 'bg-green-500/20 border-green-400/30 scale-105' 
                    : 'bg-black/20'
                }`}>
                  {/* Word study count */}
                  {wordProgress && wordProgress.timesStudied > 0 && (
                    <div className="absolute top-4 right-4 text-white/60 text-xs">
                      Studied {wordProgress.timesStudied}x
                    </div>
                  )}
                  <div className="text-white/60 text-sm mb-2 flex items-center gap-2">
                    {nativeLanguage}
                    {currentAudioStep === 'main' && (
                      <div className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
                    )}
                  </div>
                  <p className="text-white text-2xl font-medium">{getCurrentContent().targetWord}</p>
                </div>
              </div>

              {vocabulary.length === 0 && !isLoading ? (
                <div className="text-center mb-8">
                  <Button
                    onClick={handleBackToTopics}
                    className="bg-white/20 backdrop-blur-sm border border-white/30 hover:bg-white/30 text-white font-medium rounded-2xl h-12 px-8"
                  >
                    Try Different Topic or Languages
                  </Button>
                </div>
              ) : (
                <div className="flex items-center justify-center gap-8">
                  <button
                    onClick={handlePrevious}
                    className="w-14 h-14 bg-black/20 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center hover:bg-black/30 transition-all duration-300 transform hover:scale-110"
                    disabled={vocabulary.length === 0}
                  >
                    <ChevronLeft className="w-7 h-7 text-white/80" />
                  </button>

                  <button
                    onClick={handlePlay}
                    className={`w-16 h-16 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center transition-all duration-300 transform hover:scale-110 ${
                      isPlaying 
                        ? 'bg-red-500/30 hover:bg-red-500/40' 
                        : currentAudioStep === 'training'
                        ? 'bg-blue-500/30 hover:bg-blue-500/40'
                        : currentAudioStep === 'main'
                        ? 'bg-green-500/30 hover:bg-green-500/40'
                        : 'bg-black/20 hover:bg-black/30'
                    }`}
                    disabled={vocabulary.length === 0}
                  >
                    {isPlaying ? (
                      <Square className="w-8 h-8 text-white/80" />
                    ) : (
                      <Play className="w-8 h-8 text-white/80 ml-1" />
                    )}
                  </button>

                  <button
                    onClick={handleNext}
                    className="w-14 h-14 bg-black/20 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center hover:bg-black/30 transition-all duration-300 transform hover:scale-110"
                    disabled={vocabulary.length === 0}
                  >
                    <ChevronRight className="w-7 h-7 text-white/80" />
                  </button>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Single interface - only text changes */}
        {currentPage !== "confirmation" && currentPage !== "learning" && (
          <div className={`text-center mb-12 transition-all duration-300 ease-in-out ${isTransitioning ? 'opacity-30 scale-95' : 'opacity-100 scale-100'}`}>
            <h1 className="text-3xl font-normal text-white mb-8 transition-all duration-500">{questionText}</h1>

            {/* Search Bar */}
            <div className="mb-6">
              <div className="relative">
                <Search className="absolute left-4 top-1/2 transform -translate-y-1/2 w-5 h-5 text-white/40" />
                <Input
                  type="text"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-2xl h-12 text-white placeholder:text-white/40 focus:border-white/30 focus:ring-0 pl-12 text-base"
                  placeholder="Search languages..."
                />
              </div>
            </div>

            {/* Language Grid */}
            <div className="max-h-80 overflow-y-auto space-y-2 mb-6">
              {filteredLanguages.map((language) => (
                <button
                  key={language.code}
                  onClick={() => handleLanguageSelect(language)}
                  className="w-full text-left p-4 bg-black/20 backdrop-blur-sm border border-white/10 rounded-2xl hover:bg-black/30 transition-all duration-300 transform hover:scale-[1.02]"
                >
                  <div className="flex items-center justify-between">
                    <p className="text-white font-medium">{language.name}</p>
                  </div>
                </button>
              ))}
            </div>

            {/* Selected Language Display */}
            {((currentPage === "native" && nativeLanguage) || (currentPage === "target" && targetLanguage)) && (
              <div className="mb-8">
                <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-2xl p-6">
                  <p className="text-white font-medium text-lg">
                    {currentPage === "native" ? nativeLanguage : targetLanguage}
                  </p>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Page 3: Confirmation */}
        {currentPage === "confirmation" && (
          <div className="text-center transition-all duration-500 ease-in-out">
            <div className="mb-8">
              <div className="flex items-center justify-center gap-4 mb-10">
                <button
                  onClick={() => handleLanguageCardClick("native")}
                  className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-2xl p-3 flex-1 hover:bg-black/30 transition-all duration-300 transform hover:scale-[1.02]"
                >
                  <p className="text-white font-medium text-base">{nativeLanguage}</p>
                </button>
                <div className="flex items-center justify-center">
                  <Languages className="w-6 h-6 text-white/60" />
                </div>
                <button
                  onClick={() => handleLanguageCardClick("target")}
                  className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-2xl p-3 flex-1 hover:bg-black/30 transition-all duration-300 transform hover:scale-[1.02]"
                >
                  <p className="text-white font-medium text-base">{targetLanguage}</p>
                </button>
              </div>

              {/* Progress Summary */}
              {userProgress && (
                <div className="mb-6 grid grid-cols-3 gap-2 text-center">
                  <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-lg p-3">
                    <div className="text-blue-400 text-sm">Level</div>
                    <div className="text-white font-bold text-lg">{userProgress.level}</div>
                  </div>
                  <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-lg p-3">
                    <div className="text-green-400 text-sm">Words</div>
                    <div className="text-white font-bold text-lg">{userProgress.totalWordsStudied}</div>
                  </div>
                  <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-lg p-3">
                    <div className="text-orange-400 text-sm">Streak</div>
                    <div className="text-white font-bold text-lg">{userProgress.currentStreak}</div>
                  </div>
                </div>
              )}

              <div className="mb-6">
                <h2 className="text-white text-xl font-medium mb-8">Choose your topic</h2>
                <div className="grid grid-cols-2 gap-4 max-h-80 overflow-y-auto hide-scrollbar">
                  {topics.map((topic) => {
                    const iconData = TOPIC_ICONS.find(icon => icon.id === topic.id)
                    const IconComponent = iconData?.icon || MessageCircle
                    return (
                      <button
                        key={topic.id}
                        onClick={() => handleTopicSelect(topic)}
                        className={`bg-black/20 backdrop-blur-sm border border-white/10 rounded-2xl p-5 text-center hover:bg-black/30 transition-all duration-300 transform hover:scale-[1.02] ${
                          selectedTopic?.id === topic.id ? "bg-white/20 border-white/30" : ""
                        }`}
                      >
                        <div className="flex flex-col items-center gap-3">
                          <IconComponent className="w-5 h-5 text-white/80" />
                          <p className="text-white/90 text-sm font-medium leading-tight">{topic.name}</p>
                        </div>
                      </button>
                    )
                  })}
                </div>
              </div>
            </div>
          </div>
        )}

        {showSettings && (
          <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 z-50">
            <div className="bg-black/40 backdrop-blur-xl border border-white/10 rounded-[32px] p-8 w-full max-w-lg max-h-[90vh] overflow-y-auto">
              <div className="flex items-center justify-between mb-8">
                <h2 className="text-2xl font-medium text-white">Settings</h2>
                <button
                  onClick={handleSettingsClose}
                  className="w-10 h-10 bg-black/20 backdrop-blur-sm border border-white/10 rounded-full flex items-center justify-center hover:bg-black/30 transition-all duration-300"
                >
                  <X className="w-5 h-5 text-white/80" />
                </button>
              </div>

              <div className="space-y-8">
                {/* Autoplay Section */}
                <div>
                  <h3 className="text-lg font-medium text-white mb-6">Playback</h3>
                  
                  <div className="space-y-4">
                    <div className="flex items-center justify-between">
                      <div>
                        <p className="text-white/80 text-sm">Auto-play</p>
                        <p className="text-white/50 text-xs">Automatically play audio when words change</p>
                      </div>
                      <button
                        onClick={() => updateSetting("autoPlay", !settings.autoPlay)}
                        className={`w-12 h-6 rounded-full transition-all duration-300 ${
                          settings.autoPlay 
                            ? "bg-blue-500" 
                            : "bg-black/30 border border-white/20"
                        }`}
                      >
                        <div className={`w-5 h-5 bg-white rounded-full transition-all duration-300 ${
                          settings.autoPlay ? "translate-x-6" : "translate-x-0.5"
                        }`} />
                      </button>
                    </div>
                  </div>
                </div>

                {/* Pace Section */}
                <div>
                  <h3 className="text-lg font-medium text-white mb-6">Pace</h3>

                  <div className="space-y-6">
                    <div>
                      <p className="text-white/80 text-sm mb-3">Pronunciation Speed:</p>
                      <div className="flex gap-3">
                        {["Slow", "Normal", "Fast"].map((speed) => (
                          <button
                            key={speed}
                            onClick={() => updateSetting("pronunciationSpeed", speed)}
                            className={`px-6 py-3 rounded-xl transition-all duration-300 ${
                              settings.pronunciationSpeed === speed
                                ? "bg-white/20 border border-white/30 text-white"
                                : "bg-black/20 border border-white/10 text-white/70 hover:bg-black/30"
                            }`}
                          >
                            {speed}
                          </button>
                        ))}
                      </div>
                    </div>

                    <div>
                      <p className="text-white/80 text-sm mb-3">Pause Duration between translations:</p>
                      <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-xl p-4">
                        <input
                          type="range"
                          min="0.2"
                          max="10"
                          step="0.1"
                          value={settings.pauseBetweenTranslations}
                          onChange={(e) => updateSetting("pauseBetweenTranslations", Number.parseFloat(e.target.value))}
                          className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
                        />
                        <div className="flex justify-between text-white/60 text-xs mt-2">
                          <span>0.2s</span>
                          <span className="text-white">{settings.pauseBetweenTranslations}s</span>
                          <span>10s</span>
                        </div>
                      </div>
                    </div>

                    <div>
                      <p className="text-white/80 text-sm mb-3">Pause Duration for the next word:</p>
                      <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-xl p-4">
                        <input
                          type="range"
                          min="0.2"
                          max="10"
                          step="0.1"
                          value={settings.pauseForNextWord}
                          onChange={(e) => updateSetting("pauseForNextWord", Number.parseFloat(e.target.value))}
                          className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
                        />
                        <div className="flex justify-between text-white/60 text-xs mt-2">
                          <span>0.2s</span>
                          <span className="text-white">{settings.pauseForNextWord}s</span>
                          <span>10s</span>
                        </div>
                      </div>
                    </div>

                    <div>
                      <p className="text-white/80 text-sm mb-3">Repeat Target Language Word:</p>
                      <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-xl p-4">
                        <input
                          type="range"
                          min="1"
                          max="5"
                          step="1"
                          value={settings.repeatTargetLanguage}
                          onChange={(e) => updateSetting("repeatTargetLanguage", Number.parseInt(e.target.value))}
                          className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
                        />
                        <div className="flex justify-between text-white/60 text-xs mt-2">
                          <span>1x</span>
                          <span className="text-white">{settings.repeatTargetLanguage}x</span>
                          <span>5x</span>
                        </div>
                      </div>
                    </div>

                    <div>
                      <p className="text-white/80 text-sm mb-3">Repeat Main Language Word:</p>
                      <div className="bg-black/20 backdrop-blur-sm border border-white/10 rounded-xl p-4">
                        <input
                          type="range"
                          min="1"
                          max="5"
                          step="1"
                          value={settings.repeatMainLanguage}
                          onChange={(e) => updateSetting("repeatMainLanguage", Number.parseInt(e.target.value))}
                          className="w-full h-2 bg-white/20 rounded-lg appearance-none cursor-pointer slider"
                        />
                        <div className="flex justify-between text-white/60 text-xs mt-2">
                          <span>1x</span>
                          <span className="text-white">{settings.repeatMainLanguage}x</span>
                          <span>5x</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <Button
                onClick={handleSettingsClose}
                className="w-full mt-8 bg-black/20 backdrop-blur-sm border border-white/10 hover:bg-black/30 text-white font-medium rounded-2xl h-12"
              >
                Done
              </Button>
            </div>
          </div>
        )}
      </div>
      
      {/* Progress Dashboard */}
      {showProgressDashboard && (
        <ProgressDashboard onClose={() => setShowProgressDashboard(false)} />
      )}
      
      {/* Achievement Notifications */}
      {newAchievements.length > 0 && (
        <div className="fixed top-4 right-4 z-50 space-y-2">
          {newAchievements.map((achievement) => (
            <div
              key={achievement.id}
              className="bg-green-500/90 backdrop-blur-lg text-white p-4 rounded-lg shadow-lg border border-green-400/50 transform transition-all duration-500 animate-bounce"
            >
              <div className="flex items-center space-x-3">
                <span className="text-2xl">{achievement.icon}</span>
                <div>
                  <div className="font-bold">Achievement Unlocked!</div>
                  <div className="text-sm">{achievement.name}</div>
                </div>
                <button
                  onClick={dismissNewAchievements}
                  className="text-white/80 hover:text-white text-lg ml-2"
                >
                  ‚úï
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
